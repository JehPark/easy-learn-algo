# Exercise

### 01 원소들이 다음 순서로 배열에 저장되어 있다. [12, 70, 30, 20, 55, 25]

#### (1) 선택 정렬
가장 큰 원소를 먼저 찾고 찾은 원소를 정렬되지 않은 배열의 끝으로 보낸다.  
[12, (70), 30, 20, 55, 25]  
[12, 25, 30, 20, 55, 70] (20 <=> 70)  

#### (2) 버블 정렬
두개를 비교해서 가장 큰 원소를 뒤로 계속해서 한칸씩 보낸다.


[12, (70), 30, 20, 55, 25]  
[12, 30, (70), 20, 55, 25]  
[12, 30, 20, (70), 55, 25]  
...  
[12, 30, 20, 55, 25, (70)]  

#### (3) 삽입 정렬
맨앞에서 부터 정렬을하고 정렬된 부분의 배열에 알맞게 원소를 끼워넣는다.  
[12, \ 70, 30, 20, 55, 25]  
[12, 70 \, 30, 20, 55, 25]  
[12, 30, 70 \, 20, 55, 25]  

### 02 원소들이 다음 순서로 배열에 저장되어 있다. [12, 70, 30, 20, 55, 25, 40, 50]
#### (1) 병합 정렬
[12, 70, 30, 20, 55, 25, 40, 50]  
[12, 70, 20, 30, 25, 30, 40, 50]  
[12, 20, 30, 70, 25, 30, 40, 50]  
[12, 20, 25, 30, 30, 40, 50, 70]  
#### (2) 힙 정렬
힙 구조화 ->  
[12, 25, 20, 30, 55, 40, 50, 70]  
이후에 힙 정렬 ->
루트를 계속해서 pop을 진행 한 후에 힙 구조화를 진행.

### 03 퀵정렬을 이용해라
[12, 70, 30, 20, 55, 25, 40, 50]  
50을 기준으로 작은 원소는 왼편에 큰 원소를 오른편으로 넣는다.  
[12, 30, 20, 25, 40, 50, 70, 55]  
40을 기준으로 왼쪽 배열 내에서 같은 작업을 반복한다.  
[12, 30, 20, 25, 40, 50, 70, 55]  
55을 기준으로 오른쪽 배열내에서 같은 작업을 반복한다.
[12, 30, 20, 25, 40, 50, 55, 77]  
25를 기준으로 왼쪽 배열내에서 같은 작업을 반복한다.  
[12, 20, 25, 30, 40, 50, 55, 77]  

### 04 n개의 원소가 정렬되지 않은 상태로 배열에 저장되어 있다. 이를 대상으로 다음 작업들을 수행 할 때 소요되는 시간으 O-표기법으로 밝히시오.
#### (1) 가장 큰 원소 찾기
O(n) => 무조건 한번은 배열에 있는 원소들을 한번씩 훑어 봐야한다.  
#### (2) 가장 큰 원소와 작은 원소를 동시에 찾기
O(n) => 찾는다는 계산은 상수의 계산이므로 (1)번과 같은 값을 갖는다.  
#### (3) 힙으로 바꾸기
O(n) => 언뜻 본다면 O(log(n))같지만 그렇지 않고 n값을 갖는다.

### 05-06 n개의 원소가 정렬되지 않은 상태로 배열에 저장되어 있다. 이를 대상으로 다음 정렬 작업을 수행할 때 최악의 경우 소요되는 시간을 O-표기법으로 밝히시오.
![image](https://user-images.githubusercontent.com/83111342/117811855-085eb980-b29c-11eb-8216-a10527234c37.png)
해당 사진이 조금더 설명이 쉬워 첨부한다.  

### 07 [알고리즘 4-3]의 삽입 정렬에서 2는 A[1]부터 A[i-1]까지 정렬되어 있는 상태에서 A[i]가 들어갈 자리를 찾는다. 이를 위해 A[i-1]부터 시작해 왼쪽으로 차례로 훑어 나간다. 이렇게 하면 평균적으로 i-1/2 번의 비교가 필요하다. A[1 ... i-1]이 이미 정렬되어 있으므로  이진 탐색을 이용하면 i-1/2 대신 log(i - 1)번의 비교로 자리를 찾을 수 있다. 이렇게 하면 삽입 정렬의 수행 시간이 절약될 것 같지만 그렇지가 않다. 이유가 무엇인가?
실제로는 서치타임이 줄어들기때문에 전체적인 시간은 줄어 들겠지만 스왑하는 시간이 여전히 O(n)이기 때문에 결국, 워스트케이스에서 시간은 변하지 않는다.

### 08 배열 A[1...n]이 임의의 정렬 알고리즘의 입력으로 들어온다. 이때 배열이 이미 정렬되어 있는 상태이면 다음 중 어떤 정렬 알고리즘이 가장 효율적이겠는가
삽입 정렬 : 비교나 스왑이 필요가 없어져서 O(n)으로 계산된다.  
버블 정렬 : 플래그를 사용한다면 같은 효과를 얻을 수 있다.  

### 09 여섯 가지의 정렬 알고리즘들은 일반적인 시간 복잡도 관점에서 볼 때 세 그룹으로 나눌 수 있다. 어떻게 나누겠는가?

